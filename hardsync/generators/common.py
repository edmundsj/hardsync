import re
import os
import enum
import logging
from typing import Mapping, Sequence, TypeVar
from pathlib import Path
from hardsync.types import PopulatedFile
import hardsync

logger = logging.getLogger('generator')


class CaseType(enum.Enum):
    CAMEL_CASE = "camelCase"
    SNAKE_CASE = "snake_case"
    PASCAL_CASE = "PascalCase"
    UNKNOWN = "UNKNOWN"


class Language(enum.Enum):
    ARDUINO = "arduino"
    CPP = "cpp"
    PYTHON = "python"


def indent(language: Language):
    if language == language.ARDUINO or language == language.CPP:
        return "    "
    elif language == language.PYTHON:
        return "    "
    raise ValueError(f"Unspported language {language}")


CPP_INDENT = indent(language=Language.CPP)
ARDUINO_INDENT = indent(language=Language.ARDUINO)
PYTHON_INDENT = indent(language=Language.PYTHON)



def detect_case(s: str) -> CaseType:
    if re.match('^[a-z]+([A-Z][a-z0-9]+)+$', s):
        return CaseType.CAMEL_CASE
    elif re.match('^[a-z]+(_[a-z0-9]+)+$', s):
        return CaseType.SNAKE_CASE
    elif re.match('^[A-Z][a-z0-9]+([A-Z][a-z0-9]+)*$', s):
        return CaseType.PASCAL_CASE
    else:
        return CaseType.UNKNOWN


def convert_case(s: str, to_case: CaseType) -> str:
    # Convert any case to snake_case
    s = re.sub('([a-z0-9])([A-Z])', r'\1_\2', s).lower()

    if to_case == CaseType.SNAKE_CASE:
        return s
    elif to_case == CaseType.CAMEL_CASE:
        return re.sub('_([a-z])', lambda x: x.group(1).upper(), s)
    elif to_case == CaseType.PASCAL_CASE:
        return s.title().replace('_', '')
    else:
        raise ValueError(f"Unsupported target case: {to_case}")


def comment_string(language: Language) -> str:
    if language == Language.PYTHON:
        return '#'
    elif language == Language.CPP:
        return '//'
    elif language == Language.ARDUINO:
        return '//'
    else:
        raise ValueError(f'Unspported language {language}. No comment string found.')


def populate_template(template: str, replacements: Mapping[str, Sequence[str]], language: Language) -> str:
    populated_template = template
    comment_sequence = comment_string(language=language)
    for key, val in replacements.items():
        var_to_match = comment_sequence + ' {{' + key + '}}'
        whitespace = starting_whitespace(input_string=template, match_string=var_to_match)
        join_string = '\n' + whitespace
        composite_string = join_string.join(val)

        populated_template = populated_template.replace(var_to_match, composite_string)

    return populated_template


def starting_whitespace(input_string: str, match_string: str) -> str:
    lines = input_string.split('\n')
    leading_spaces = 0
    for line in lines:
        if match_string in line:
            leading_spaces = len(line) - len(line.lstrip())
    whitespaces = ' ' * leading_spaces

    return whitespaces


def write(dirname: Path, file: PopulatedFile, force=False, preface=''):
    full_path = dirname / file.filename
    if os.path.exists(full_path) and file.is_main and not force:
        logger.info(f"Found existing main file {file.filename} at {full_path}. Skipping write. Override this by adding the --force flag")
        return

    with open(full_path, 'w') as file_to_write:
        file_to_write.write(preface)
        file_to_write.write(file.content)
        logger.info(f"Wrote {full_path}")


def preface_string(language: Language) -> str:
    startswith = comment_string(language=language) + ' '
    endswith = '\n'
    lines = [
        'File auto-generated by hardsync',
        f'hardsync_version: {hardsync.__version__}',
        f'hardsync_hash: {hardsync.__hash__}',
    ]
    preface = ''
    for line in lines:
        preface += startswith + line + endswith
    lines.append('\n')

    return preface
